        0 module objfunc
        - 
        - include("bsplines.jl")
        - include("timestep.jl")
        - 
        - using LinearAlgebra
        - using Plots
        - 
        - struct parameters
        - 	N ::Int64		# vector dimension
        - 	Nguard ::Int64 	# number of extra levels
        - 	T::Float64		# final time
        - 	testadjoint::Bool #should this really be in param?
        - 	maxpar::Float64
        - 	cfl::Float64
        - 	utarget
        - 
        - 
        - 	function parameters(N, Nguard,T, testadjoint, maxpar,cfl)	
        - 	  Ntot = N + Nguard 
        - 	  Ident = Matrix{Float64}(I, Ntot, Ntot)  
        -  	  utarget = Ident[1:Ntot,1:N]
        -       utarget[:,3] = Ident[:,4]
        -       utarget[:,4] = Ident[:,3]	
        - 
        - 	  new(N, Nguard, T, testadjoint, maxpar, cfl, utarget)
        - 	end
        - 
        - 	function parameters(N, Nguard,T, testadjoint, maxpar,cfl, utarget)		
        - 	  new(N, Nguard, T, testadjoint, maxpar, cfl, utarget)
        - 	end
        - 	#multiple dispatch with extra struct for H0 = 0 ?
        - end
        - 
        - function traceobjgrad(pcof0::Array{Float64,1} = [0.0; 0.0; 0.0],  params::parameters = parameters(4, 3, 150, 1, 0.09, 0.05), order::Int64 =2, verbose::Bool = false, retadjoint::Bool = true)
       32 	N = params.N   	
        0 	Nguard = params.Nguard 	
        0 	T = params.T
        - 	testadjoint = params.testadjoint
        - 	labframe = false
        0 	utarget = params.utarget
        0 	cfl = params.cfl
        -   
        -  # Parameters used for the gradient
        -  kpar = 1
        - 
        - 	eps = 1e-9
        0 	xi = 1.0/Nguard  	# coef for penalizing forbidden states
        - 
        0 	Ntot = N + Nguard
        0 	pcof = pcof0
        0 	D = size(pcof,1)
        - 
        - 	# Make sure that each element of pcof is in the prescribed range
       32 	pcof, par1, par0 = boundcof(pcof, D, params.maxpar, eps)
        - 
        - 	
        0 	if verbose
        0     	println("Vector dim Ntot =", Ntot , ", Guard levels Nguard = ", Nguard , ", Param dim D = ", D , ", pcof(1) = ", pcof[1], ", CFL = ", cfl)
        -   end
        -  
        -   # sub-matricesfor the Hamiltonian
     1968   H0 ,amat, adag, omega, domega = rotframematrices(Ntot)
      304   zeromat = zeros(Ntot,N) 
        -   
        -   # patameters for tbsplines
       32   dtknot = T/(D - 2)
     7552   splineparams = bsplines.splineparams(T, D, D+1, dtknot.*(collect(1:D) .- 1.5), dtknot.*(collect(1:D+1) .- 2), dtknot, pcof)
        - 
        -     	# control functions
        -   nurbscontrol = 1
        - 
        0   if retadjoint
        0     @inline rfgrad(t::Float64) = bsplines.gradbspline2(t,splineparams)
        0     @inline ifgrad(t::Float64) = zeros(length(pcof))
        -   end
        - 
        -   	# parameters for time integrator
     1856   pcofmax = maximum(abs.(pcof))
      592   K1 =  pcofmax.*( amat .+  adag)
        0   lamb = eigvals(K1)
       16   maxeig2 = maximum(lamb)
      144   maxeig1 = maximum(abs.(domega))./(2*pi)
        - 
        0   if verbose
        0 		 println("max(d_omega) = ", maximum(abs.(domega)), ", maxeig1 = ", maxeig1,", pcofmax =" ,pcofmax ,", maxeig2 = ", maxeig2)
        -   end
        - 
       48   maxeig = 0.5(maxeig1 + maxeig2)
       32   dt = cfl/maxeig
       48   nsteps = ceil(Int64,T/dt)
       32   dt = T/nsteps
        - 
      176   gamma, stages = timestep.getgamma(order)
        - 
        0   if verbose
        0    	println("Final time: ", T, ", number of time steps: " , nsteps , ", time step: " , dt )
        -   end
        - 
        -     # the basis for the initial data as a matrix
        0   Ident = Matrix{Float64}(I, Ntot, Ntot)
      304   U0 = Ident[1:Ntot,1:N]
        -   W0 = zeromat
        - 
      304   rotr = Diagonal(cos.(omega*T))
      304   roti = Diagonal(sin.(omega*T))
        -  
        0   vtargetr = rotr*utarget
        0   vtargeti = roti*utarget
        -  
        -   #real and imagianary part of initial condition
        -   vr = U0
        -   vi = zeromat
        - 
        0   if verbose
        0   	usaver = zeros(Ntot,N,nsteps+1)
        0    	usavei = zeros(Ntot,N,nsteps+1)
        0    	usaver[:,:,1] = vr
        0    	usavei[:,:,1] = -vi
        -   end
        -     #for computing objfalpha1
        - 
        0   t = 0.0
        -   step = 0
        -   objfv = 0.0
        - 
        - 
        -   wr = zeromat
        -   wi = zeromat
        - 
        -   objf_alpha1 = 0.0
        - 
        - 
        -   # Preallocate
      496   Ktmp = Stmp = tmp1 = tmp2 = tmp3 = tmp4 = K0 = S0 =K05= S05 =K1 =S1 = dar =dai = zeros(Ntot,Ntot)
        -   gr1 =gi1 = hr1 = hi1 = darr = dari = dair = daii = zeromat
        - 
        -     # Forward time stepping loop
    28256   for step in 1:nsteps
        -     #for the objective function
  2160384     infidelity0 = weightf(t, T)*(1-tracefidreal(vr, vi, vtargetr, vtargeti, labframe, t, omega))
  1915392     forbidden0 = xi*penalf(t, T)*normguard(vr, vi, Nguard)
        - 
        0     if retadjoint
  2160384       scomplex0 = tracefidcomplex(vr, -vi, vtargetr, vtargeti, labframe, t, omega)
  2160384       salpha0 = tracefidcomplex(wr, -wi, vtargetr, vtargeti, labframe, t, omega)
        0       forbalpha0 = xi*penalf(t,T)*screal(vr, vi, wr, wi, Nguard,zeromat)
        - 
  2516736       rgrad = rfgrad(t)
  2516736       igrad = ifgrad(t)
        - 
  1804032       dar = rotmatr(t,domega)*amat
  2004480       dai = rotmati(t,domega)*amat #adag?
        0       rfalpha = rgrad[kpar]
    22272       ifalpha = igrad[kpar]
        - 
  5211648       gr0 = rfalpha.*( (dai .-  dai')*vr .- (dar .+ dar')*vi) .+ ifalpha.*(  (dai .+ dai')*vi .+ (dar .-  dar')*vr) #should it really be ifalpha' and ralpha' here?? Different n anders code ..
  5902080       gi0 = rfalpha.*( (dar .+  dar')*vr .+ (dai .- dai')*vi) .+ ifalpha.*( -(dai .+ dai')*vr .+ (dar .-  dar')*vi)
        -     end
        - 
        -     # Stromer-Verlet
        0     for q in 1:stages
        0       if retadjoint
        -        t0=t
        -        vr0 = vr
        -        vi0 = vi
        -       end
        - 
        - 
        -      #K2 = K(K0,t, amat, adag, domega, splineparams, H0)
        -      
        0      K!(Ktmp, t, amat, adag, domega, splineparams, H0, tmp1, tmp2, tmp3) 
   690432      K0 = copy(Ktmp) 
        0      S!(Stmp, t, amat, adag, domega, splineparams,tmp1, tmp2, tmp3)   
   690432      S0 = copy(Stmp)
    66816      K!(Ktmp, t + 0.5*dt*gamma[q], amat, adag, domega, splineparams, H0,tmp1,tmp2,tmp3)
   690432      K05 = copy(Ktmp)  
    66816      S!(Stmp,t + 0.5*dt*gamma[q], amat, adag, domega, splineparams,tmp1,tmp2,tmp3) 
   690432      S05 = copy(Stmp)
    66816      K!(Ktmp, t +dt*gamma[q], amat, adag, domega, splineparams, H0,tmp1,tmp2,tmp3)
   690432      K1 = copy(Ktmp)
    66816      S!(Stmp, t + dt*gamma[q], amat, adag, domega, splineparams,tmp1,tmp2,tmp3) 
   690432      S1 = copy(Stmp)
        - 
        -      # K0 = K(K0,t, amat, adag, domega, splineparams, H0)
        -      # display(K0)
        -      # S0 = S(S0,t, amat, adag, domega, splineparams)   
        -      # K05 = K(K05,t + 0.5*dt*gamma[q], amat, adag, domega, splineparams, H0)
        -      # S05 = S(S05,t + 0.5*dt*gamma[q], amat, adag, domega, splineparams) 
        -       #K1 = K(K1,t + dt*gamma[q], amat, adag, domega, splineparams, H0)
        -      # S1 = S(S1,t + dt*gamma[q], amat, adag, domega, splineparams) 
        - 
        -        
  9064704       @inbounds t, vr, vi = timestep.step(t, vr, vi, dt*gamma[q], K0, S0, K05, S05, K1, S1, Ident)
        - 
  2160384     	infidelity = weightf(t, T)*(1-tracefidreal(vr, vi, vtargetr, vtargeti, labframe,t, omega))
  1915392     	forbidden = xi*penalf(t, T)*normguard(vr, vi, Nguard)
    66816     	objfv = objfv + gamma[q]*dt*0.5*(infidelity0 + infidelity + forbidden0 + forbidden)
        -      	infidelity0 = infidelity
        -     	forbidden0 = forbidden		
        - 
        0       if retadjoint	
        -       # Forcing evolving w
  2160384        scomplex1 = tracefidcomplex(vr, -vi, vtargetr, vtargeti, labframe, t, omega)
  1803888        dar = rotmatr(t,domega)*amat
  2004480        dai = rotmati(t,domega)*amat
  2516736        rgrad = rfgrad(t)
  2516736        igrad = ifgrad(t)
        0        rfalpha = rgrad[kpar] #Will this return the same va
    22272        ifalpha = igrad[kpar]
        - 
  5233920        gr1 = rfalpha'.*( (dai .-  dai')*vr .- (dar .+ dar')*vi) .+ ifalpha'.*(  (dai .+ dai')*vi .+ (dar .-  dar')*vr) #should it really be ifalpha' and ralpha' here?? Different n anders code ..
  5924352        gi1 = rfalpha'.*( (dar .+  dar')*vr .+ (dai .- dai')*vi) .+ ifalpha'.*( -(dai .+ dai')*vr .+ (dar .-  dar')*vi)
        - 
  9911040        @inbounds temp, wr, wi = timestep.step(t0, wr, wi, dt*gamma[q], gi0, 0.5*(gr1 + gr0), gi1, K0, S0, K05, S05, K1, S1, Ident) 
        - 
  2160384        salpha1 = tracefidcomplex(wr, -wi, vtargetr, vtargeti, labframe, t, omega)
        0        forbalpha1 =  xi*penalf(t,T)*screal(vr, vi, wr, wi, Nguard,zeromat)   
   133632        objf_alpha1 = objf_alpha1 - gamma[q]*dt*0.5*2.0*real(weightf(t0,T)*conj(scomplex0)*salpha0 +
        -           weightf(t,T)*conj(scomplex1)*salpha1) + gamma[q]*dt*0.5*2.0*(forbalpha0 + forbalpha1)
        -      
        -        # save previous values for next stage
        -        scomplex0 = scomplex1
        -        salpha0 = salpha1
        -        forbalpha0 = forbalpha1
        -        gr0 = gr1
        0        gi0 = gi1
        -       end  # retadjoint
        -     end # Stromer-Verlet
        -     
        0     if verbose
        0       usaver[:,:, step + 1] = vr
    44512       usavei[:,:, step + 1] = -vi
        -     end
        - 
        -   end #forward time steppingloop
        - 
      944 	ufinalr = rotr'*vr - roti'*vi #should both these matrices be transposed?
     1088 	ufinali = -rotr'*vi - roti'*vr 
   153888 	ineqpenalty = evalineqpen(pcof, par0, par1);
      144 	objfv = objfv .+ ineqpenalty
        - 
        - 
        0   if retadjoint
        -     dfdp = objf_alpha1
     1808     gradobjfadj = zeros(D,1);
        -     t = T
       16     dt = -dt
        -     adiffmax = 0
        -   
        -     # terminal conditions for the adjoint state
        -     lambdar = zeromat
        -     lambdai = zeromat
        - 
        -     
        -     #Backward time stepping loop
    28240     for step in nsteps-1:-1:0
  2160384       scomplex0 = tracefidcomplex(vr, -vi, vtargetr, vtargeti, labframe, t, omega)
        0       sr0 = real(scomplex0)
        0       si0 = imag(scomplex0)
        - 
  1759488       hr0 = -weightf(t,T)/N*(sr0*vtargetr + si0*vtargeti)
  1759488       hi0 =  weightf(t,T)/N*(sr0*vtargeti - si0*vtargetr)
   668160       hr0[N+1:N+Nguard,:] = xi*penalf(t,T)*vr[N+1:N+Nguard,:]
   668160       hi0[N+1:N+Nguard,:] = xi*penalf(t,T)*vi[N+1:N+Nguard,:]
        - 
        -       # forcing for evolving W (d psi/d alpha1) in the rotating frame
  1804032       dar = rotmatr(t,domega)*amat
  2004480       dai = rotmati(t,domega)*amat
  2516736       rgrad = rfgrad(t)
  2516736       igrad = ifgrad(t)
        - 
        -       # separate out contributions from rfgrad and ifgrad (which determine the component of the gradient)
  2650368       darr = ( (dai .- dai')*vr .- (dar .+ dar')*vi)
  2650368       dari = ( (dar .+ dar')*vr .+ (dai .- dai')*vi)
  2650368       dair = ( (dai .+ dai')*vi .+ (dar .- dar')*vr)
  3340800       daii = (-(dai .+ dai')*vr .+ (dar .- dar')*vi)
   868608       tr_adjrf = tracefidreal(darr, dari, lambdar, lambdai)
   868608       tr_adjif = tracefidreal(dair, daii, lambdar, lambdai)
 12605952       tr_adj0  = rfgrad(t)* tr_adjrf + ifgrad(t)* tr_adjif
        - 
        -         #loop over stages
        0         for q in 1:stages
        -           t0 = t
        -           vr0 = vr
        -           vi0 = vi
        -       
        0           K!(Ktmp, t, amat, adag, domega, splineparams, H0, tmp1, tmp2, tmp3) 
   690432           K0 = copy(Ktmp) 
        0           S!(Stmp, t, amat, adag, domega, splineparams,tmp1, tmp2, tmp3)   
   690432           S0 = copy(Stmp)
    66816           K!(Ktmp, t + 0.5*dt*gamma[q], amat, adag, domega, splineparams, H0,tmp1,tmp2,tmp3)
   690432           K05 = copy(Ktmp)  
    66816           S!(Stmp,t + 0.5*dt*gamma[q], amat, adag, domega, splineparams,tmp1,tmp2,tmp3) 
   690432           S05 = copy(Stmp)
    66816           K!(Ktmp, t +dt*gamma[q], amat, adag, domega, splineparams, H0,tmp1,tmp2,tmp3)
   690432           K1 = copy(Ktmp)
    66816           S!(Stmp, t + dt*gamma[q], amat, adag, domega, splineparams,tmp1,tmp2,tmp3) 
   690432           S1 = copy(Stmp)
        -           
        -          # K0 = K(K0,t, amat, adag, domega, splineparams, H0)
        -          # S0 = S(S0,t, amat, adag, domega, splineparams)   
        -          # K05 = K(K05,t + 0.5*dt*gamma[q], amat, adag, domega, splineparams, H0)
        -          # S05 = S(S05,t + 0.5*dt*gamma[q], amat, adag, domega, splineparams) 
        -          # K1 = K(K1,t + dt*gamma[q], amat, adag, domega, splineparams, H0)
        -          # S1 = S(S1,t + dt*gamma[q], amat, adag, domega, splineparams) #
        - #
        - 
        -           # evolve vr, vi
  9064704           @inbounds t, vr, vi = timestep.step(t, vr, vi, dt*gamma[q], K0, S0, K05, S05, K1, S1, Ident)
        - 
  2160384           scomplex1 = tracefidcomplex(vr, -vi, vtargetr, vtargeti, labframe, t, omega)
        0           sr1 = real(scomplex1)
        0           si1 = imag(scomplex1)
        - 
  1759488           hr1 = -weightf(t,T)/N*(sr1*vtargetr + si1*vtargeti)
  1759488           hi1 =  weightf(t,T)/N*(sr1*vtargeti - si1*vtargetr)
   668160           hr1[N+1:N+Nguard,:] = xi*penalf(t,T)*vr[N+1:N+Nguard,:]
   668160           hi1[N+1:N+Nguard,:] = xi*penalf(t,T)*vi[N+1:N+Nguard,:]
        - 
        - 
        -           # evolve lambdar, lambdai
  9911040           @inbounds temp, lambdar, lambdai = timestep.step(t0, lambdar, lambdai, dt*gamma[q], hi0, 0.5*(hr0 + hr1), hi1, K0, S0, K05, S05, K1, S1, Ident)
        - 
  1804032           dar = rotmatr(t,domega)*amat
  2004480           dai = rotmati(t,domega)*amat
  2516736           rgrad = rfgrad(t)
  2516736           igrad = ifgrad(t)
        -           
  2650368           darr = ( (dai .- dai')*vr .- (dar .+ dar')*vi)
  2650368           dari = ( (dar .+ dar')*vr .+ (dai .- dai')*vi)
  2650368           dair = ( (dai .+ dai')*vi .+ (dar .- dar')*vr)
  3340800           daii = (-(dai .+ dai')*vr .+ (dar .- dar')*vi)
   868608           tr_adjrf = tracefidreal(darr, dari, lambdar, lambdai)
   868608           tr_adjif = tracefidreal(dair, daii, lambdar, lambdai)
 12605952           tr_adj1  = rfgrad(t)*tr_adjrf + ifgrad(t)*tr_adjif
        - 
        -           # accumulate the gradient of the objective functional
  7550208           gradobjfadj = gradobjfadj + gamma[q]*dt*0.5*2.0*(tr_adj0 +  tr_adj1) # dt is negative
        - 
        -           # save for next stage
        -           scomplex0 = scomplex1
        -           tr_adj0 = tr_adj1
        -           hr0 = hr1
    44512           hi0 = hi1
        -         end 
        -     end 
        -  
    97808     ineqpengrad = evalineqgrad(pcof, par0, par1)
        - 
        -   
       64     for k in 1:D
    15968       gradobjfadj[k] = gradobjfadj[k] + ineqpengrad[k]
        -     end
        -   end
        - 
        0 	if verbose
        0 		println("Inequality penalty: ", ineqpenalty)
        0 		dfdp = dfdp + ineqpengrad[kpar]
        0 		println("Forward integration of gradient of objective function = ", dfdp, " ineqpengrad = ", ineqpengrad[kpar])
        - 		
        0 		nplot = 1 + nsteps
        0 		println(" Column   Vnrm")
        0 		for q in 1:N
        0 	 		Vnrm = usaver[:,q,nplot]' * usaver[:,q,nplot] + usavei[:,q,nplot]' * usavei[:,q,nplot]
        0 	 		Vnrm = sqrt(Vnrm)
        0 	 		println(q, " | ", Vnrm)
        - 		end
        - 
        0 		tplot = range(0, stop = T, length = nplot)
        - 		c = 3 #what is this?
        - 		q = 3
        - 
        0 		plt1 = plotunitary(usaver + 1im*usavei,T)
        - 
        - 		# Evaluate polynomials at the discrete time levels
        - 		# Evaluate all polynomials on the midpoint grid
        0 		td = collect(range(0, stop = T, length = nsteps +1))
        - 
        0     rplot(t) = rfunc(t,splineparams)
        0     eplot(t) = efunc(t,splineparams)
        - 
        0 		f1 = plot(td, vcat(rplot.(collect(td))...), lab = "Real", title = "Control function", linewidth = 2)
        0 		f2 = plot(td, vcat(eplot.(collect(td))...), title = "Envelope function", linewidth = 2)
        0 		f3 = plot(td, weightf.(td,T), lab = "Gate", title = "Weight functions", linewidth = 2)
        - 
        0 		plot!(td, penalf.(td,T), lab = "Forbidden", linewidth = 2)
        - 
        0 		plt2 = plot(f1,f2,f3, layout = (3,1))    
        - 	end
        - 
        -   # perhaps not the most pretty construction
        0 	if verbose
        0      if retadjoint
        0       return plt1, plt2, objfv, gradobjfadj
        -      end
        0     return plt1, plt2, objfv   
        -   end
        -  
        0  if retadjoint
       32   return objfv, gradobjfadj
        -  end
        - 
        0  return objfv
        - end
        - 
        - 
        - # returns omega
        - function omegafun(N::Int64)
      144 	omega = zeros(N)
        0   	omega[1] = 0
        0   	omega[2] = 4.106
        0   	omega[3] = 7.992
        0   	omega[4] = 11.659
        0   	if N >= 6
        0   	  omega[5] = 15.105
        0   	  omega[6] = 18.332
        -   	end
        0   	if N >= 7
        0   	  omega[7] = 21.339
        -   	end
        0   	if N > 7
        0   	  error("not enough frequencies known")
        -   	end
        - 
        0   	return omega
        - end
        - 
        - # bound pcof to allowed amplitude
        - @inline function boundcof(pcof::Array{Float64,1}, D::Int64, maxpar::Float64, eps::Float64)
        - 	par1 = maxpar
        - 	par0 = -maxpar
        - 
        - 	for q in 1:D
        -   	  if pcof[q] > par1-eps
        -   	    pcof[q] = par1-eps
        -   	  end
        -   	  if pcof[q] < par0+eps
        -   	    pcof[q] = par0+eps
        -   	  end
        -   	end
        - 	return pcof, par1, par0
        - end
        - 
        - # Matrices for te hamiltonian in rotation frame
        - @inline function rotframematrices(Ntot::Int64)
        -     omega = omegafun(Ntot)
        - 	  H0 = zeros(Ntot,Ntot)
        -   	amat = Array(Bidiagonal(zeros(Ntot),sqrt.(collect(1:Ntot-1)),:U))
        -   	adag = Array(transpose(amat))
        -   	domega = zeros(Ntot)
        -   	domega[1:Ntot-1] = omega[2:Ntot] .- omega[1:Ntot-1]
        - 
        - 	return H0, amat, adag, omega, domega
        - end
        - 
        - 
        - @inline function weightf(t::Float64, T::Float64)
        - # period
        -   tp = T/10
        -   xi = 4/tp # scale factor
        -   
        - # center time
        -   tc = T
        -   tau = (t - tc)/tp
        -   mask = (tau >= -0.5) & (tau <= 0.5)
        -   w = xi*64*mask.*(0.5 + tau).^3 .* (0.5 - tau).^3
        - end
        - 
        - @inline function tracefidreal(ur::Array{Float64,2}, vi::Array{Float64,2}, vtargetr::Array{Float64,2}, vtargeti::Array{Float64,2}, labframe::Bool,t::Float64,omega::Array{Float64,1})
        -   N = size(vtargetr,2)
        - 
        -   if labframe
        -   	rotmatc = Diagonal(cos.(omega*t))
        -   	rotmats = Diagonal(sin.(omega*t))
        -     ua = rotmatc * ur + rotmats * vi # ur = + Re(u), vi = - Im(u)
        -     va = rotmats * ur - rotmatc * vi
        -   else
        -     ua = ur
        -     va = -vi
        -   end
        -  
        -   fidelity = (tr(ua' * vtargetr + va' * vtargeti)/N)^2 + (tr(ua' * vtargeti - va' * vtargetr)/N)^2
        - 
        - end
        - 
        - @inline function tracefidreal(frcr::Array{Float64,2}, frci::Array{Float64,2}, lambdar::Array{Float64,2}, lambdai::Array{Float64,2})
        -   fidreal = 0.0
        -   fidreal = tr(frcr' * lambdar + frci' * lambdai);
        - end
        - 
        - @inline function tracefidcomplex(ur::Array{Float64,2}, vi::Array{Float64,2}, vtargetr::Array{Float64,2}, vtargeti::Array{Float64,2}, labframe::Bool, t::Float64, omega::Array{Float64,1})
        -   N = size(vtargetr,2)
        -   fidreal = 0.0
        -   fid_cmplx = tr(ur' * vtargetr .+ vi' * vtargeti)/N + 1im*tr(ur' * vtargeti .- vi' * vtargetr)/N;
        - end
        - 
        - @inline function  penalf(t::Float64, T::Float64)
        -   w = 0.0
        -   constant = 1.0/T
        -   alpha = 0
        -  # period
        -   tp = T/10
        -   xi = 4/tp # scale factor for wavelet (integral over half is tp/4)
        -   # center time
        -   tc = T
        -   tau = (t - tc)/tp
        -   mask = (tau >= -0.5) & (tau <= 0.5)
        - 
        - # weigh the constant and wavelet parts such that max w = xi
        -   w = alpha * constant + (1-alpha)*xi* 64*mask.*(0.5 + tau).^3 .* (0.5 - tau).^3;
        - end
        - 
        - @inline function normguard(vr::Array{Float64,2}, vi::Array{Float64,2}, Nguard::Int64)
        -   Ntot =size(vr,1)
        -   N = size(vr,2)
        - 
        -   f = 0.0
        -   if Nguard > 0
        -     rguard = vr[N+1:N+Nguard,:] 
        -     iguard = vi[N+1:N+Nguard,:]
        -     f = sum(sum(rguard.^2, dims = 2)) + sum(sum(iguard.^2, dims = 2)) # Is this really a good substitute for sumsq? is it even right?
        -   end
        - 
        - end
        - 
        - @inline function evalineqpen(pcof::Array{Float64,1}, par_0::Float64, par_1::Float64)
        -   D = size(pcof,1)
        -   N = size(pcof,2)
        -   scalef = 0.1
        -   penalty = zeros(1,N);
        -   dp2 = par_1 - par_0
        -   
        -   for k in 1:D
        -     penalty[1,:] = penalty[1,:] .- ( log.((pcof[k,:] .- par_0)/dp2) .+ log.((par_1 .- pcof[k,:])/dp2))
        -   end
        -   penalty = scalef .* (penalty/D .- 2*log(2))
        - end
        - 
        - function plotunitary(us, T)
        0   nsteps = length(us[1,1,:])  
        0   Ntot = length(us[:,1,1])
        0   N =  length(us[1,:,1])
        - 
        0   if Ntot != N
        0     println("INFO plotunitary: Ntot= ", Ntot, " and N = ", N ," are not equal")
        -   end
        0   t = range(0, stop = T, length = nsteps)
        - 
        - # one figure for the response of each basis vector
        0   plotarray = Array{Plots.Plot}(undef, N) #empty array for separate plots
        - 
        0   for ii in 1:N
        0   		titlestr = string("Response to initial data #", ii)
        0         h = plot(title = titlestr, size = (1000, 1000))
        0   		for jj in 1:Ntot
        0   			labstr = string("State ", jj)
        0 			plot!(t, abs.(us[jj,ii,:]), lab = labstr, linewidth = 4, xlabel = "Time")
        - 		end
        0 		plotarray[ii] = h
        -   end
        0   plt = plot(plotarray..., layout = N)
        0   return plt
        - end
        - 
        - @inline function evalineqgrad(pcof::Array{Float64,1}, par0::Float64, par1::Float64)
        -   D = size(pcof,1)
        -   N = size(pcof,2)
        -   scalef = 0.1
        -   pengrad = zeros(D,N)
        -   for k in 1:D
        -     pengrad[k,:] = scalef*(1.0./(par1 .- pcof[k,:]) .- 1.0./(pcof[k,:] .- par0))/D
        -   end
        -  return pengrad
        - end
        - 
        - function screal(vr::Array{Float64,2}, vi::Array{Float64,2}, wr::Array{Float64,2}, wi::Array{Float64,2}, Nguard::Int64,vrguard::Array{Float64,2})
        0   Ntot =size(vr,1)
        0   N = size(vr,2)
        - 
        -   f=0;
        0   if  Nguard > 0 # should give the last guard much higher weight!
   489984     vrguard = vr[N+1:N+Nguard,:]
   489984     viguard = vi[N+1:N+Nguard,:]
   489984     wrguard = wr[N+1:N+Nguard,:]
   489984     wiguard = wi[N+1:N+Nguard,:]   
   890880     f = tr(vrguard*wrguard') +  tr(viguard*wiguard')
        -   end
        - 
        - end
        - 
        - @inline function K(K::Array{Float64,2},t::Float64,amat::Array{Float64,2},adag::Array{Float64,2},domega::Array{Float64,1},splineparams::bsplines.splineparams,H0::Array{Float64,2})
        -  rr = rotmatr(t,domega) 
        -  ri = rotmati(t,domega) 
        -  K = H0 + rfunc(t,splineparams).*(rr*amat + adag*rr') - ifunc(t,splineparams).*(ri*amat + adag*ri)
        - end
        - 
        - @inline function S(S::Array{Float64,2},t::Float64,amat::Array{Float64,2},adag::Array{Float64,2},domega::Array{Float64,1},splineparams::bsplines.splineparams)
        -   rr = rotmatr(t,domega)
        -   ri = rotmati(t,domega)
        -   S  = ifunc(t,splineparams).*(rr*amat - adag*rr') + rfunc(t,splineparams).*(ri*amat - adag*ri')
        - end
        - 
        - 
        - function K!(K::Array{Float64,2},t::Float64,amat::Array{Float64,2},adag::Array{Float64,2},domega::Array{Float64,1},splineparams::bsplines.splineparams,H0::Array{Float64,2},tmp1::Array{Float64,2},tmp2::Array{Float64,2},tmp3::Array{Float64,2})
        0  rr = tmp1
        -  rrt = tmp2
        -  ri = tmp3
  6681600  rr = rotmatr(t,domega)
   133632  rrt = rr'
  7884288  ri = rotmati(t,domega)
        - 
        -  # (rr*amat)
  4142592  tmp1 =copy(amat)
        0  mul!(tmp1,rr,amat) 
  4142592  tmp2 = copy(tmp1)
        0  mul!(tmp2,adag,rrt)
  4142592  tmp2 = adag*rrt
        0 @inbounds for  I in eachindex(tmp1)
        -     # (rr*amat + adag*rr')
        0     tmp3[I] = tmp1[I] + tmp2[I]
        -   end
        -   #ri*amat 
  4142592   tmp1 = copy(amat)
        0   mul!(tmp1,ri,amat)
        -   # adag*ri
  4142592   tmp2 = copy(tmp1)
        0   mul!(tmp2,adag,ri)
        - 
        0   rfeval = rfunc(t,splineparams)
        -   ifeval = ifunc(t,splineparams)
        -   
        0   @inbounds for  I in eachindex(tmp1)
        -    # (ri*amat + adag*ri)
        0     tmp4 = tmp1[I] + tmp2[I]
        0     K[I] = H0[I] + rfeval*tmp3[I] - ifeval*tmp4
        -   end
        - 
        - end
        - 
        - function S!(S::Array{Float64,2},t::Float64,amat::Array{Float64,2},adag::Array{Float64,2},domega::Array{Float64,1},splineparams::bsplines.splineparams,tmp1::Array{Float64,2},tmp2::Array{Float64,2},tmp3::Array{Float64,2})
        0   rr = tmp1
        -   ri = tmp1
  6681600   rr = rotmatr(t,domega)
  7884288   ri = rotmati(t,domega)
        -   tmp4 = 0.0
        - 
  4142592   tmp1 = copy(amat)
        0   mul!(tmp1,rr,amat)
  4142592   tmp2 = copy(tmp1)
        0   mul!(tmp2,adag,transpose(rr))
        -   
        0   @inbounds for  I in eachindex(tmp1)
        0     tmp3[I] = tmp1[I] - tmp2[I]
        -   end
        -   
  4142592   tmp1 = copy(amat)
        0   mul!(tmp1,ri,amat)
  4142592   tmp2 = copy(tmp1)
        0   mul!(tmp2,adag,transpose(ri))
        -   
        0   @inbounds for  I in eachindex(tmp1)
        0     tmp4 = tmp1[I] - tmp2[I]  
        0     S[I]  = ifunc(t,splineparams)*tmp3[I] + rfunc(t,splineparams)*tmp4
        -   end
        - end
        - 
        - 
        - @inline function rfunc(t::Float64,splineparams::bsplines.splineparams)
        -  ret = 0.0
        -  ret = bsplines.bspline2(t,splineparams)
        - end
        - 
        - @inline function efunc(t::Float64,splineparams::bsplines.splineparams)
        -   ret = 0.0
        -   ret = bsplines.bspline2(t,splineparams::bsplines.splineparams)
        - end
        - 
        - @inline function ifunc(t::Float64,splineparams::bsplines.splineparams)
        -   ret = 0.0
        - end
        - 
        - @inline function rotmatr(t::Float64,domega::Array{Float64,1})
        -   N = length(domega)
        -   rotmatr =zeros(N,N)
        -   rotmatr = Diagonal(cos.(domega*t))
        - end
        - 
        - @inline function rotmati(t::Float64,domega::Array{Float64,1})
        -   N = length(domega)
        -   rotmatr =zeros(N,N)
        -   rotmatr = Diagonal(-sin.(domega*t))
        - end
        - 
        - 
        - end
        - 
