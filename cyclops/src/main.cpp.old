#include <ctf.hpp>
#include <float.h>
#include <math.h>
using namespace CTF;

/* This routine initializes tensors for the state variables and 
   the Hamiltonian martrices.*/
void Init_Tensors(int nOsc,int* nLevels,Matrix<double> * &Hsym,Matrix<double> * &Hanti,
                  Tensor<double> &u,Tensor<double> &v,Tensor<double> &Au,
                  Tensor<double> &Av, World & dw){
  char ind_names[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  char psi_ind[100];
  int64_t * inds;
  int * sym_arr;
  int maxLevel = 1;
  int n;
  int np = dw.np;
  int offset;
  double s;
  double * vals;

  // Determine the largest number of energy levels for a given oscillator in the system.
  for(int i=0;i<nOsc;i++){
    maxLevel = (nLevels[i] >maxLevel) ? nLevels[i] : maxLevel;
  }

  vals = new double[maxLevel-1];
  inds = new int64_t[(maxLevel-1)];

  /* Allocate and initialize Hamiltonian for each oscillator*/
  Hsym  = new Matrix<>[nOsc];
  Hanti = new Matrix<>[nOsc];
  for(int i=0;i<nOsc;i++){
    n = nLevels[i];
    Hsym[i] = Matrix<>(n,n,SY,dw);
    Hanti[i] = Matrix<>(n,n,AS,dw);
    for(int j=0;j<n-1;j++){
      vals[j] = sqrt((double)(j+1))/np;
      inds[j] = (n+1)*j + n;
    }
    Hsym[i].write(n-1,inds,vals);    // a+a'
    Hsym[i].sparsify();
    Hanti[i].write(n-1,inds,vals);   // a-a'
    Hanti[i].sparsify();
  }
  sym_arr = new int[nOsc];
  for(int i=0;i<nOsc;i++){ 
    sym_arr[i] = NS;
    psi_ind[i] = ind_names[i];
  }

  /* Initialize state tensors */
  u  = Tensor<double> (nOsc, nLevels, sym_arr, dw);
  v  = Tensor<double> (nOsc, nLevels, sym_arr, dw);
  Au = Tensor<double> (nOsc, nLevels, sym_arr, dw);
  Av = Tensor<double> (nOsc, nLevels, sym_arr, dw);

  // /* Initial Condition, normalized to have probability 1. */
  u.fill_random(0.0,1.0);
  s = u.norm2();
  s = 0.5/s;
  u[psi_ind] = u[psi_ind]*s;
  v.fill_random(0.0,1.0);
  s = v.norm2();
  s = 0.5/s;
  v[psi_ind] = v[psi_ind]*s;

  // /* Initial condition: a canonical unit vector */
  // inds[0] = 1;
  // inds[1] = 2;
  // // inds[2] = 2;
  // vals[0] = sqrt(0.5)/np;
  // vals[1] = sqrt(0.5)/np;
  // // vals[2] = sqrt(0.5)/np;
  // u.write(2,inds,vals);

  // Deallocate working arrays
  delete[] vals;
  delete[] sym_arr;
  delete[] inds;
}

// /* Perform a left multiplaction by the usual control Hamiltonian for the 
//  real-valued formulation. Here we try to fuse multiplications. */
// void MatMul1(int nOsc, int* nLevels, Matrix<double>* &Hsym,
//              Matrix<double>* &Hanti, Tensor<double> &u,
//              Tensor<double> &v,Tensor<double> &Au,
//              Tensor<double> &Av, World & dw){
//   char ind_names[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
//   char psi_ind[100];
//   char Apsi_ind[100];
//   char Ham_ind[2];

//   for(int i=0;i<nOsc;i++){ 
//     psi_ind[i] = ind_names[i];
//     Apsi_ind[i] = ind_names[i];
//   }
//   // For left multiplication always sum along the second dimension
//   Ham_ind[1] = ind_names[nOsc];
//   Au = 0.0;
//   Av = 0.0;

//   /* Compute left multiplication by [K -S;S K] */
//   for(int i=0;i<nOsc;i++){
//     // Manipulate strings to contact along proper dimensions for each operator
//     Ham_ind[0] = Apsi_ind[i];
//     psi_ind[i] = ind_names[nOsc];
//     Au[Apsi_ind] += Hanti[i][Ham_ind]*u[psi_ind] - Hsym[i][Ham_ind]*v[psi_ind];
//     Av[Apsi_ind] += Hsym[i][Ham_ind]*u[psi_ind] + Hanti[i][Ham_ind]*v[psi_ind];

//     // Reset string
//     psi_ind[i] = Apsi_ind[i];
//   }

// }

/* Perform a left multiplaction by the usual control Hamiltonian for the 
 real-valued formulation. Here we try to built in functions for contractions. */
void MatMul2(int nOsc, int* nLevels, Matrix<double>* &Hsym,
             Matrix<double>* &Hanti, Tensor<double> &u,
             Tensor<double> &v,Tensor<double> &Au,
             Tensor<double> &Av, World & dw){
  char ind_names[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  char psi_ind[100];
  char Apsi_ind[100];
  char Ham_ind[2];

  for(int i=0;i<nOsc;i++){ 
    psi_ind[i] = ind_names[i];
    Apsi_ind[i] = ind_names[i];
  }
  // For left multiplication always sum along the second dimension
  Ham_ind[1] = ind_names[nOsc];
  Au = 0.0;
  Av = 0.0;

  /* Compute left multiplication by [K -S;S K] */
  for(int i=0;i<nOsc;i++){
    
    // Manipulate strings to contact along proper dimensions for each operator
    Ham_ind[0] = Apsi_ind[i];
    psi_ind[i] = ind_names[nOsc];
    
    Au.contract(1.0, Hanti[i],Ham_ind,u,psi_ind,1.0,Apsi_ind);
    Au.contract(-1.0, Hsym[i],Ham_ind,v,psi_ind,1.0,Apsi_ind);
    Av.contract(1.0, Hsym[i],Ham_ind,u,psi_ind,1.0,Apsi_ind);
    Av.contract(1.0, Hanti[i],Ham_ind,v,psi_ind,1.0,Apsi_ind);
    
    // Reset string
    psi_ind[i] = Apsi_ind[i];
  }

}

// /* Perform a right multiplaction by the usual control Hamiltonian for the 
//  real-valued formulation.*/
// void RMv1(int nOsc, int* nLevels, Matrix<double>* &Hsym,
//              Matrix<double>* &Hanti, Tensor<double> &u,
//              Tensor<double> &v,Tensor<double> &Au,
//              Tensor<double> &Av, World & dw){
//   char ind_names[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
//   char psi_ind[100];
//   char Apsi_ind[100];
//   char Ham_ind[2];

//   for(int i=0;i<nOsc;i++){ 
//     psi_ind[i] = ind_names[i];
//     Apsi_ind[i] = ind_names[i];
//   }
//   // For left multiplication always sum along the second dimension
//   Ham_ind[0] = ind_names[nOsc];
//   Au = 0.0;
//   Av = 0.0;

//   /* Compute left multiplication by [K -S;S K] */
//   for(int i=0;i<nOsc;i++){
    
//     // Manipulate strings to contact along proper dimensions for each operator
//     Ham_ind[1] = Apsi_ind[i];
//     psi_ind[i] = ind_names[nOsc];
    
//     Au[Apsi_ind] += Hanti[i][Ham_ind]*u[psi_ind] - Hsym[i][Ham_ind]*v[psi_ind];
//     Av[Apsi_ind] += Hsym[i][Ham_ind]*u[psi_ind] + Hanti[i][Ham_ind]*v[psi_ind];

//     // Reset string
//     psi_ind[i] = Apsi_ind[i];
//   }

// }

/* Perform a right multiplaction by the usual control Hamiltonian for the 
 real-valued formulation.*/
void RMv2(int nOsc, int* nLevels, Matrix<double>* &Hsym,
             Matrix<double>* &Hanti, Tensor<double> &u,
             Tensor<double> &v,Tensor<double> &Au,
             Tensor<double> &Av, World & dw){
  char ind_names[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  char psi_ind[100];
  char Apsi_ind[100];
  char Ham_ind[2];

  for(int i=0;i<nOsc;i++){ 
    psi_ind[i] = ind_names[i];
    Apsi_ind[i] = ind_names[i];
  }
  // For right multiplication always sum along the first dimension
  Ham_ind[0] = ind_names[nOsc];
  Au = 0.0;
  Av = 0.0;

  /* Compute left multiplication by [K -S;S K] */
  for(int i=0;i<nOsc;i++){
    // Manipulate strings to contact along proper dimensions for each operator
    Ham_ind[1] = Apsi_ind[i];
    psi_ind[i] = ind_names[nOsc];
    
    Au.contract(1.0, Hanti[i],Ham_ind,u,psi_ind,1.0,Apsi_ind);
    Au.contract(-1.0, Hsym[i],Ham_ind,v,psi_ind,1.0,Apsi_ind);
    Av.contract(1.0, Hsym[i],Ham_ind,u,psi_ind,1.0,Apsi_ind);
    Av.contract(1.0, Hanti[i],Ham_ind,v,psi_ind,1.0,Apsi_ind);
    
    // Reset string
    psi_ind[i] = Apsi_ind[i];
  }

}

int main(int argc, char ** argv){
  int rank, np, pass;
  int nOsc = 1;
  int maxOsc = 3;
  int * nLevels;
  double st_time, end_time;
  double timings[4];

  FILE *extFile;
  char fName[100];

  Matrix<double> * Hsym;
  Matrix<double> * Hanti;
  Tensor<double> u;
  Tensor<double> v;
  Tensor<double> Au;
  Tensor<double> Av;

  // Initialize MPI
  MPI_Init(&argc, &argv);
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  MPI_Comm_size(MPI_COMM_WORLD, &np);

  // Define ctf world object
  World dw(MPI_COMM_WORLD,argc, argv);

  if(rank == 0){
    sprintf(fName, "Time_%2.2i.txt", np);
    extFile = fopen(fName, "w");
  }

  // Loop over increasing number of "oscillators"
  for(int iter=0;iter<maxOsc;iter++){
    // nOsc = 2*(iter+1);
    nOsc = iter+1;
    nLevels = new int[nOsc];
    for(int i=0;i<nOsc;i++) nLevels[i] = 2;
    

    Init_Tensors(nOsc,nLevels,Hsym,Hanti,u,v,Au,Av,dw);

    // Left multiplication (fused)
    st_time = MPI_Wtime();
    // MatMul1(nOsc,nLevels, Hsym,Hanti, u,v,Au,Av,dw);
    end_time = MPI_Wtime();
    timings[0] = end_time-st_time;

    // Left multiplication (contraction)
    st_time = MPI_Wtime();
    MatMul2(nOsc,nLevels, Hsym,Hanti, u,v,Au,Av,dw);
    end_time = MPI_Wtime();
    timings[1] = end_time-st_time;

    // Right multiplication (fused)
    st_time = MPI_Wtime();
    // RMv1(nOsc,nLevels, Hsym,Hanti, u,v,Au,Av,dw);
    end_time = MPI_Wtime();
    timings[2] = end_time-st_time;

    // Right multiplication (contraction)
    st_time = MPI_Wtime();
    RMv2(nOsc,nLevels, Hsym,Hanti, u,v,Au,Av,dw);
    end_time = MPI_Wtime();
    timings[3] = end_time-st_time;

    if(rank == 0){
      fprintf(extFile, "%4.4i %10.9e %10.9e %10.9e %10.9e\n", nOsc, timings[0], timings[1], timings[2], timings[3]);
    }
    u.~Tensor();
    v.~Tensor();
    Au.~Tensor();
    Av.~Tensor();
    delete[] nLevels;
    delete[] Hanti;
    delete[] Hsym;
  }
  if(rank==0) fclose(extFile);

  MPI_Finalize();
  return 0;
}
